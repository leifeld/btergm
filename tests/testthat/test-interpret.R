context("test micro-level interpretation functions")

test_that("edgeprob works with one-mode ERGM with network object", {
  skip_on_cran()
  set.seed(12345)
  data("chemnet")
  com <- committee %*% t(committee)
  nw <- network(pol, directed = TRUE)
  model1 <- ergm::ergm(nw ~ edges + edgecov(com) + istar(2))
  expect_error(ep <- edgeprob(model1), NA)
  expect_s3_class(ep, "data.frame")
  expect_equal(dim(ep), c(870, 10))
  expect_equal(colnames(ep), c("tie", "edges", "edgecov.com[[i]]", "istar2", "i", "j", "t", "i.name", "j.name", "probability"))
  expect_equal(ep$i[1], 1)
  expect_equal(ep$j[1], 2)
  expect_equal(ep$i.name[1], "BMA")
  expect_equal(ep$j.name[1], "BML")
  expect_false(any(is.na(ep$i.name)))
  expect_false(any(is.na(ep$j.name)))
  expect_equal(class(ep$probability), "numeric")
  expect_equal(class(ep$i), "integer")
  expect_equal(class(ep$j), "integer")
  expect_equal(class(ep$t), "integer")
  expect_equal(class(ep$i.name), "character")
  expect_equal(class(ep$j.name), "character")
  expect_equal(class(ep$tie), "integer")
  expect_lte(max(ep$probability), 1)
  expect_gte(max(ep$probability), 0)
})

test_that("edgeprob works with one-mode ERGM with matrix", {
  skip_on_cran()
  set.seed(12345)
  data("chemnet")
  com <- committee %*% t(committee)
  model1 <- ergm::ergm(pol ~ edges + edgecov(com) + istar(2))
  expect_error(ep <- edgeprob(model1), NA)
  expect_s3_class(ep, "data.frame")
  expect_equal(dim(ep), c(870, 10))
  expect_equal(colnames(ep), c("tie", "edges", "edgecov.com[[i]]", "istar2", "i", "j", "t", "i.name", "j.name", "probability"))
  expect_equal(ep$i[1], 1)
  expect_equal(ep$j[1], 2)
  expect_equal(ep$i.name[1], "BMA")
  expect_equal(ep$j.name[1], "BML")
  expect_false(any(is.na(ep$i.name)))
  expect_false(any(is.na(ep$j.name)))
  expect_equal(class(ep$probability), "numeric")
  expect_equal(class(ep$i), "integer")
  expect_equal(class(ep$j), "integer")
  expect_equal(class(ep$t), "integer")
  expect_equal(class(ep$i.name), "character")
  expect_equal(class(ep$j.name), "character")
  expect_equal(class(ep$tie), "integer")
  expect_lte(max(ep$probability), 1)
  expect_gte(max(ep$probability), 0)
})

test_that("edgeprob works with bipartite ERGM", {
  skip_on_cran()
  set.seed(12345)
  data("chemnet")
  cm <- network(committee, bipartite = TRUE, directed = FALSE)
  set.vertex.attribute(cm, "type", types[, 1])
  suppressMessages(model1 <- ergm::ergm(cm ~ edges + nodefactor("type", levels = 1) + b1star(2)))
  expect_error(ep <- edgeprob(model1), NA)
  expect_s3_class(ep, "data.frame")
  expect_equal(dim(ep), c(600, 10))
  expect_equal(colnames(ep), c("tie", "edges", "nodefactor.type.gov", "b1star2", "i", "j", "t", "i.name", "j.name", "probability"))
  expect_equal(ep$i[1], 1)
  expect_equal(ep$j[1], 31)
  expect_equal(ep$i.name[1], "BMA")
  expect_equal(ep$j.name[1], "IPU")
  expect_false(any(is.na(ep$i.name)))
  expect_false(any(is.na(ep$j.name)))
  expect_equal(class(ep$probability), "numeric")
  expect_equal(class(ep$i), "integer")
  expect_equal(class(ep$j), "integer")
  expect_equal(class(ep$t), "integer")
  expect_equal(class(ep$i.name), "character")
  expect_equal(class(ep$j.name), "character")
  expect_equal(class(ep$tie), "integer")
  expect_lte(max(ep$probability), 1)
  expect_gte(max(ep$probability), 0)
})